{"version":3,"sources":["error-collector.ts"],"names":[],"mappings":"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","file":"error-collector.js","sourceRoot":"","sourcesContent":["import {Injectable, EventEmitter, Optional, Inject} from \"@angular/core\";\nimport {AnonymousSubscription} from \"rxjs/Subscription\";\nimport {FieldErrors, FieldError, addFieldErrors} from \"./field-error\";\nimport {RikeEventSource, RikeEvent, RikeErrorEvent} from \"./event\";\nimport {RikeTarget} from \"./rike\";\n\n/**\n * Field errors subscription.\n *\n * The `unsubscribe()` method should be called to stop receiving error notifications.\n */\nexport interface ErrorSubscription {\n\n    /**\n     * After this method called the error notifications won't be sent to subscriber.\n     *\n     * This method should be called in order to release all resources associated with subscription.\n     */\n    unsubscribe(): void;\n\n    /**\n     * Request field errors to be updated by notifying the subscriber.\n     *\n     * Does nothing after `unsubscribe()` method called.\n     */\n    refresh(): this;\n\n}\n\n/**\n * An error collecting service.\n *\n * It collects errors from all available [Rike event sources][RikeEventSource]. It uses `fieldErrors()` method\n * to obtain a `FieldErrors` instance from {{RikeErrorEvent}}. Then it notifies all subscribers on when errors received\n * or removed.\n *\n * This service is registered automatically along with every event source by `provideEventSource()` function.\n * But unlike event sources it is not a multi-provider.\n *\n * An instance of this class could be created on its own. Then it is necessary to subscribe it on Rike events with\n * `subscribeOn` method.\n */\n\nexport class ErrorCollector {\n\n    private readonly _emitters: {[field: string]: FieldEmitter} = {};\n    private readonly _targetErrors: {[target: string]: TargetErrors} = {};\n    private _initialized = false;\n\n    constructor(  private _eventSources?: RikeEventSource[]) {\n    }\n\n    /**\n     * Subscribes this collector on the given Rike events emitter.\n     *\n     * @param events Rike events emitter to subscribe on.\n     */\n    public subscribeOn(events: EventEmitter<RikeEvent>): AnonymousSubscription {\n        return events.subscribe(\n            (event: RikeEvent) => this.handleEvent(event),\n            (error: RikeErrorEvent) => this.handleError(error));\n    }\n\n    /**\n     * Adds subscription for errors corresponding to the given field.\n     *\n     * If the field name is `\"*\"`, then subscriber will be notified on error changes for all fields except those ones\n     * with existing subscriptions.\n     *\n     * @param field target field name.\n     * @param next function that will be called on every target field errors update.\n     * @param error function that will be called on errors.\n     * @param complete function that will be called when no more errors will be reported.\n     *\n     * @return {ErrorSubscription} subscription.\n     */\n    public subscribe(\n        field: string,\n        next: ((errors: FieldErrors) => void),\n        error?: (error: any) => void,\n        complete?: () => void): ErrorSubscription {\n        this.init();\n        return this.fieldEmitter(field).subscribe(next, error, complete);\n    }\n\n    /**\n     * Adds subscription for errors corresponding to all fields except those ones with existing subscriptions.\n     *\n     * Calling this method is the same as calling `subscribe(\"*\", next, error, complete);`.\n     *\n     * @param next function that will be called on every errors update.\n     * @param error function that will be called on errors.\n     * @param complete function that will be called when no more errors will be reported.\n     *\n     * @return {ErrorSubscription} subscription.\n     */\n    public subscribeForRest(\n        next: ((errors: FieldErrors) => void),\n        error?: (error: any) => void,\n        complete?: () => void): ErrorSubscription {\n        return this.subscribe(\"*\", next, error, complete);\n    }\n\n    //noinspection JSMethodCanBeStatic\n    /**\n     * Converts error to `FieldErrors`.\n     *\n     * This method uses `addFieldErrors` function by default. Override it if you are using custom error handler.\n     *\n     * @param error arbitrary error passed in [RikeEvent.error] field.\n     *\n     * @return {FieldErrors} field errors.\n     */\n    protected fieldErrors(error: RikeErrorEvent): FieldErrors {\n\n        const errorResponse = error.errorResponse;\n\n        if (errorResponse) {\n            return addFieldErrors(errorResponse).fieldErrors;\n        }\n\n        return {\n            \"*\": [\n                {message: errorEventMessage(error)} as FieldError\n            ]\n        };\n    }\n\n    private fieldEmitter(field: string) {\n        return this._emitters[field] || (\n            this._emitters[field] = new FieldEmitter(field, this._emitters, this._targetErrors));\n    }\n\n    private init() {\n        if (this._initialized) {\n            return;\n        }\n\n        this._initialized = true;\n        if (this._eventSources) {\n            for (let src of this._eventSources) {\n                this.subscribeOn(src.rikeEvents);\n            }\n        }\n    }\n\n    private handleEvent(event: RikeEvent) {\n\n        let affectedFields: {[field: string]: any};\n\n        if (!event.error) {\n            affectedFields = this.clearTargetErrors(event.target);\n        } else {\n            affectedFields = this.targetErrors(event.target)\n                .addAll(this.fieldErrors((event as any) as RikeErrorEvent));\n        }\n\n        for (let field in affectedFields) {\n            if (field !== \"*\" && affectedFields.hasOwnProperty(field)) {\n                this.notify(field);\n            }\n        }\n\n        this.notify(\"*\");// Always notify about common errors\n    }\n\n    private handleError(error: RikeErrorEvent) {\n        this.targetErrors(error.target).add(\"*\", {message: errorEventMessage(error)});\n        this.notify(\"*\");\n    }\n\n    private targetErrors(target: RikeTarget<any, any>): TargetErrors {\n\n        const id = target.uniqueId;\n\n        return this._targetErrors[id] || (this._targetErrors[id] = new TargetErrors(target, this._emitters));\n    }\n\n    private clearTargetErrors(target: RikeTarget<any, any>): {[field: string]: any} {\n\n        const id = target.uniqueId;\n        const targetErrors = this._targetErrors[id];\n\n        if (!targetErrors) {\n            return {};\n        }\n\n        delete this._targetErrors[id];\n\n        return targetErrors.fieldsWithErrors;\n    }\n\n    private notify(field: string) {\n\n        const emitter = this._emitters[field];\n\n        if (emitter) {\n            emitter.notify();\n        }\n    }\n\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Array, decorators: [{ type: Inject, args: [RikeEventSource, ] }, { type: Optional }, ]},\n];\n}\n\nfunction errorEventMessage(error: RikeErrorEvent): string {\n    if (error.cancel) {\n        if (!error.cancelledBy) {\n            return \"Cancelled\";\n        }\n        return \"Cancelled by `\" + error.cancelledBy.operation.name + \"` operation\";\n    }\n    return error.error.toString();\n}\n\nclass FieldEmitter {\n\n    private _emitter = new EventEmitter<FieldErrors>();\n    private _counter = 0;\n\n    constructor(\n        private _field: string,\n        private _emitters: {[field: string]: FieldEmitter},\n        private _targetErrors: {[target: string]: TargetErrors}) {\n    }\n\n    subscribe(\n        next: ((errors: FieldErrors) => void),\n        error?: (error: any) => void,\n        complete?: () => void): ErrorSubscription {\n\n        const subscr = this._emitter.subscribe(next, error, complete) as AnonymousSubscription;\n\n        this._counter++;\n\n        return new ErrorSubscr(this, subscr).subscribe(next, error, complete);\n    }\n\n    notify(emitter?: EventEmitter<FieldErrors>) {\n\n        const errors: FieldErrors = {};\n\n        for (let id in this._targetErrors) {\n            if (this._targetErrors.hasOwnProperty(id)) {\n                this._targetErrors[id].appendTo(this._field, errors);\n            }\n        }\n\n        (emitter || this._emitter).emit(errors);\n    }\n\n    unsubscribed() {\n        if (!--this._counter) {\n            delete this._emitters[this._field];\n        }\n    }\n\n}\n\nclass ErrorSubscr implements ErrorSubscription {\n\n    private readonly _refreshEmitter = new EventEmitter<FieldErrors>();\n    private _refreshSubscription: AnonymousSubscription;\n\n    constructor(private _fieldEmitter: FieldEmitter, private _subscription?: AnonymousSubscription) {\n    }\n\n    subscribe(\n        next: ((errors: FieldErrors) => void),\n        error?: (error: any) => void,\n        complete?: () => void): this {\n        this._refreshSubscription = this._refreshEmitter.subscribe(next, error, complete);\n        return this;\n    }\n\n    unsubscribe(): void {\n        if (!this._subscription) {\n            return;\n        }\n        try {\n            this._subscription.unsubscribe();\n            this._refreshSubscription.unsubscribe();\n        } finally {\n            delete this._subscription;\n            this._fieldEmitter.unsubscribed();\n        }\n    }\n\n    refresh(): this {\n        if (!this._subscription) {\n            return this;\n        }\n        this._fieldEmitter.notify(this._refreshEmitter);\n        return this;\n    }\n\n}\n\nclass TargetErrors {\n\n    private _errors: FieldErrors;\n\n    constructor(\n        public target: RikeTarget<any, any>,\n        private _emitters: {[field: string]: any},\n        errors?: FieldErrors) {\n        this._errors = errors || {};\n    }\n\n    get fieldsWithErrors(): {[field: string]: any} {\n        return this._errors;\n    }\n\n    add(field: string, ...errors: FieldError[]) {\n\n        const existing = this._errors[field];\n\n        if (!existing) {\n            this._errors[field] = errors;\n        } else {\n            this._errors[field].push(...errors);\n        }\n    }\n\n    addAll(errors: FieldErrors): {[field: string]: any} {\n        for (let field in errors) {\n            if (errors.hasOwnProperty(field)) {\n                this.add(field, ...errors[field]);\n            }\n        }\n        return errors;\n    }\n\n    appendTo(field: string, out: FieldErrors) {\n        if (field !== \"*\") {\n            // Append errors for the given field.\n            appendErrorsTo(field, out, this._errors[field]);\n            return;\n        }\n\n        // Append errors for all fields except the ones with subscribers.\n        for (let f in this._errors) {\n            if (f === \"*\" || this._errors.hasOwnProperty(f) && !this._emitters[f]) {\n                appendErrorsTo(f, out, this._errors[f]);\n            }\n        }\n    }\n\n}\n\nfunction appendErrorsTo(field: string, fieldErrors: FieldErrors, errors: FieldError[] | undefined) {\n    if (!errors || !errors.length) {\n        return;\n    }\n\n    const errs = fieldErrors[field];\n\n    if (errs) {\n        errs.push(...errors);\n    } else {\n        fieldErrors[field] = errors;\n    }\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}